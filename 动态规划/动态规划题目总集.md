## 第一题

[D-小彩的数组选数_牛客周赛 Round 114](https://ac.nowcoder.com/acm/contest/119273/D)

链接：[D-小彩的数组选数_牛客周赛 Round 114](https://ac.nowcoder.com/acm/contest/119273/D)  
来源：牛客网  

## 题目描述

小红喜欢 1，小紫喜欢 2，小彩喜欢 3。

现在他们拿到了一个仅由 1,2,3 组成的长为 n 的数组 a，她们可以进行若干次如下操作：

∙ 小红可以选择数组中的任意一个 1，将其变为 0 并获得 1 分，之后将与其相邻的两个元素变为 0。

∙ 小紫可以选择数组中的任意一个 2，将其变为 0 并获得 2 分，之后将与其相邻的两个元素变为 0。

∙ 小彩可以选择数组中的任意一个 3，将其变为 0 并获得 3 分，之后将与其相邻的两个元素变为 0。  

现在小彩想知道，她们最多可以获得多少分？

```java
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        //
        int n = Integer.parseInt(br.readLine());
        int[]arr = new int[n],dp = new int[n];//清楚i位置及之前为0能得到最大分数
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i = 0;i < n;i++){
            arr[i] = Integer.parseInt(st.nextToken());
        }
        if(n <= 2){
            pw.println(n == 1?arr[0]:Math.max(arr[0],arr[1]));
            pw.flush();
            pw.close();br.close();return;
        }
        dp[0] = arr[0];
        dp[1] = arr[1];
        dp[2] = Math.max(dp[0] + arr[2],dp[1]);
        for(int i = 3;i < n;i++){
            dp[i] = dp[i - 1];//不选
            //选的话只考虑dp[i - 2],dp[i -  3];i - 3 , i - 2 , i - 1 , i,考虑dp[i - 4]的话i - 2就没有清零
            dp[i] = Math.max(dp[i],dp[i-2] + arr[i]);
            dp[i] = Math.max(dp[i],dp[i-3] + arr[i]);
        }
        pw.println(dp[n - 1]);
        //
        pw.flush();
        pw.close();br.close();
    }


}
```

## 第二题

[D-施魔法_牛客2025秋季算法编程训练联赛2-提升组](https://ac.nowcoder.com/acm/contest/119774/D)

```
链接：https://ac.nowcoder.com/acm/contest/119774/D
来源：牛客网

牛可乐有 n 个元素( 编号 1..n )，第 i 个元素的能量值为 ai
 。
牛可乐可以选择至少 k 个元素来施放一次魔法，魔法消耗的魔力是这些元素能量值的极差。形式化地，若所用元素编号集合为 S，则消耗的魔力为 
集合中最大值减去最小值。
牛可乐要求每个元素必须被使用恰好一次。
牛可乐想知道他最少需要多少魔力才能用完所有元素，请你告诉他。
```

```java
import java.io.*;
import java.util.*;
//要么延长一段，要么重开一段，重开一段k即可，再长的没必要，延长一段包含了因为
public class Main {
    static BufferedReader br;
    static PrintWriter pw;
    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        //
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        int[]arr = new int[n];
        st = new StringTokenizer(br.readLine());
        for(int i = 0;i < n;i++){
            arr[i] = Integer.parseInt(st.nextToken());
        }
        Arrays.sort(arr);
        int[]dp = new int[n];
        dp[k - 1] = arr[k - 1] - arr[0];
        for(int i = k;i < n;i++){
            dp[i] = arr[i] - arr[0];
            dp[i] = Math.min(dp[i],dp[i - 1] - arr[i - 1] + arr[i]);//延长长度
            if(i - k >= k - 1)dp[i] = Math.min(dp[i],dp[i - k] + arr[i] - arr[i - k + 1]);//另开一段
        }
        System.out.println(dp[n - 1]);
        //
        pw.flush();
        pw.close();br.close();
    }
    public  static int quick_mi(long a,long p,long mod){
        int res = 1;
        while(p > 0){
            if((p & 1) == 1){
                res = (int)(a * res % mod);
            }
            p >>= 1;
            a = a * a % mod;
        }return res;
    }


}
```

## 第三题

[E-牛牛的宝可梦Go_牛客2025秋季算法编程训练联赛3-提升组](https://ac.nowcoder.com/acm/contest/120456/E)

**时空约束+动态最优事件选择**

## 📌 核心思路

预处理任意两点最短路

将事件按时间排序,事件顺序固定 → DP 按时间推进

DP 状态设计

设：

`dp[x] = 若干状态 (time, value) 表示到达地点 x 的不同时间点能获得的最高价值`

注意：  
我们对每个地点维护一个按时间递增的状态序列，且：

📌 **价值必须是前缀不降的**  
因为价值少的状态永远不会更优

---

### ✅ 状态转移

对每个事件 (t, v, val)，尝试从所有 u 转移：如果能赶到：

`arrive_time = t - dist[u][v] 找到 dp[u] 中 time ≤ arrive_time 的最优状态`

二分查找：

`int idx = upper(dp.get(u), arrive_time)`

更新最优值：

`best = max(best, dp[u][idx].value + val)`

如果该事件可达，将其加入 dp[v]

并维护前缀最大性质：

只加入比最后一个状态更优的状态

```java
import java.io.*;
import java.util.*;

public class Main {
    static BufferedReader br;
    static PrintWriter pw;
    static final int MOD = 1000000007;

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int t = 1;
        while (t-- > 0) {
            solve();
        }
        pw.flush();
        pw.close();
        br.close();
    }

    public static void solve() throws IOException {
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken()),m = Integer.parseInt(st.nextToken());
        int[][]dis = new int[n + 1][n + 1];
        final int NIL = Integer.MAX_VALUE / 2;
        for(int i = 1;i <= n;i++){
            Arrays.fill(dis[i],NIL);
            dis[i][i] = 0;
        }
        for(int u,v,i = 1;i <= m;i++){
            st = new StringTokenizer(br.readLine());
            u = Integer.parseInt(st.nextToken());v = Integer.parseInt(st.nextToken());
            dis[u][v] = dis[v][u] = 1;
        }
        for(int z = 1;z <= n;z++){
            for(int i = 1;i <= n;i++){
                for(int j = 1;j <= n;j++){
                    dis[i][j] = dis[j][i] = Math.min(dis[i][j],dis[i][z] + dis[z][j]);
                }
            }
        }
        int k = Integer.parseInt(br.readLine());
        int[][]e = new int[k][3];
        for(int i = 0;i < k;i++){
            st = new StringTokenizer(br.readLine());
            e[i][0] = Integer.parseInt(st.nextToken());e[i][1] = Integer.parseInt(st.nextToken());e[i][2]  = Integer.parseInt(st.nextToken());
        }
        Arrays.sort(e,(a,b)->{
            return a[0] <= b[0]?-1:1;
        });
        List<List<long[]>>dp =new ArrayList<>();
        for(int i = 0;i <= n;i++)dp.add(new ArrayList<>());
        dp.get(1).add(new long[]{0,0});
        long res = 0;
        for(int i = 0;i < k;i++){
            long t = e[i][0],val = e[i][2];
            int v = e[i][1];
            long bestVal = Integer.MIN_VALUE;
            for(int u = 1;u <= n;u++){
                if(dis[u][v] == NIL)continue;
                long need = t - dis[u][v];
                if(need < 0)continue;
                int find = upper(dp,u,(int)need);
                if(find == -1)continue;
                bestVal = Math.max(bestVal,dp.get(u).get(find)[1] + val);
            }
            if(bestVal != Integer.MIN_VALUE){
                dp.get(v).add(new long[]{t,bestVal});
            }
            res = Math.max(res,bestVal);
        }
        pw.println(res);
    }
    public static int upper(List<List<long[]>> dp,int k,int t){
        int l = 0,r = dp.get(k).size() - 1,res = -1;
        while(l <= r){
            int mid = (l + r) / 2;
            if(dp.get(k).get(mid)[0] <= t){
                res = mid;l = mid + 1;
            }else{
                r = mid - 1;
            }
        }
        return res;
    }

}
```

.
