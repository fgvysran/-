## 第一题

[D-小彩的数组选数_牛客周赛 Round 114](https://ac.nowcoder.com/acm/contest/119273/D)

链接：[D-小彩的数组选数_牛客周赛 Round 114](https://ac.nowcoder.com/acm/contest/119273/D)  
来源：牛客网  

## 题目描述

小红喜欢 1，小紫喜欢 2，小彩喜欢 3。

现在他们拿到了一个仅由 1,2,3 组成的长为 n 的数组 a，她们可以进行若干次如下操作：

∙ 小红可以选择数组中的任意一个 1，将其变为 0 并获得 1 分，之后将与其相邻的两个元素变为 0。

∙ 小紫可以选择数组中的任意一个 2，将其变为 0 并获得 2 分，之后将与其相邻的两个元素变为 0。

∙ 小彩可以选择数组中的任意一个 3，将其变为 0 并获得 3 分，之后将与其相邻的两个元素变为 0。  

现在小彩想知道，她们最多可以获得多少分？

```java
import java.io.*;
import java.util.*;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        //
        int n = Integer.parseInt(br.readLine());
        int[]arr = new int[n],dp = new int[n];//清楚i位置及之前为0能得到最大分数
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i = 0;i < n;i++){
            arr[i] = Integer.parseInt(st.nextToken());
        }
        if(n <= 2){
            pw.println(n == 1?arr[0]:Math.max(arr[0],arr[1]));
            pw.flush();
            pw.close();br.close();return;
        }
        dp[0] = arr[0];
        dp[1] = arr[1];
        dp[2] = Math.max(dp[0] + arr[2],dp[1]);
        for(int i = 3;i < n;i++){
            dp[i] = dp[i - 1];//不选
            //选的话只考虑dp[i - 2],dp[i -  3];i - 3 , i - 2 , i - 1 , i,考虑dp[i - 4]的话i - 2就没有清零
            dp[i] = Math.max(dp[i],dp[i-2] + arr[i]);
            dp[i] = Math.max(dp[i],dp[i-3] + arr[i]);
        }
        pw.println(dp[n - 1]);
        //
        pw.flush();
        pw.close();br.close();
    }


}
```

## 第二题

[D-施魔法_牛客2025秋季算法编程训练联赛2-提升组](https://ac.nowcoder.com/acm/contest/119774/D)

```
链接：https://ac.nowcoder.com/acm/contest/119774/D
来源：牛客网

牛可乐有 n 个元素( 编号 1..n )，第 i 个元素的能量值为 ai
 。
牛可乐可以选择至少 k 个元素来施放一次魔法，魔法消耗的魔力是这些元素能量值的极差。形式化地，若所用元素编号集合为 S，则消耗的魔力为 
集合中最大值减去最小值。
牛可乐要求每个元素必须被使用恰好一次。
牛可乐想知道他最少需要多少魔力才能用完所有元素，请你告诉他。
```

```java
import java.io.*;
import java.util.*;
//要么延长一段，要么重开一段，重开一段k即可，再长的没必要，延长一段包含了因为
public class Main {
    static BufferedReader br;
    static PrintWriter pw;
    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        //
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        int[]arr = new int[n];
        st = new StringTokenizer(br.readLine());
        for(int i = 0;i < n;i++){
            arr[i] = Integer.parseInt(st.nextToken());
        }
        Arrays.sort(arr);
        int[]dp = new int[n];
        dp[k - 1] = arr[k - 1] - arr[0];
        for(int i = k;i < n;i++){
            dp[i] = arr[i] - arr[0];
            dp[i] = Math.min(dp[i],dp[i - 1] - arr[i - 1] + arr[i]);//延长长度
            if(i - k >= k - 1)dp[i] = Math.min(dp[i],dp[i - k] + arr[i] - arr[i - k + 1]);//另开一段
        }
        System.out.println(dp[n - 1]);
        //
        pw.flush();
        pw.close();br.close();
    }
    public  static int quick_mi(long a,long p,long mod){
        int res = 1;
        while(p > 0){
            if((p & 1) == 1){
                res = (int)(a * res % mod);
            }
            p >>= 1;
            a = a * a % mod;
        }return res;
    }


}
```
