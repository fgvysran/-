## 第一题

[P3191 [HNOI2007] 紧急疏散（EVACUATE） - 洛谷](https://www.luogu.com.cn/problem/P3191)

建图转化为最大流，二分答案,然后用dinic算法解决

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,m;
const int N = 23;
const int M = 1e5 + 10;
char mp[N][N];
int h[M / 2],to[M],nxt[M],idx,step[M],cur[M];
long long val[M];
struct Node{
    int x,y;
}q[M];
int q2[M];
int R,D;
int dis[N * N][N][N],G[N][N];
int dx[]{-1,0,1,0},dy[]{0,1,0,-1};
void bfs_dis(int id,int x,int y){
    int head = 0,tail = 0;
    q[tail++] = {x,y};
    for(int i = 0;i < n;i++){
        for(int j = 0;j < m;j++){
            dis[id][i][j] = -1;
        }
    }dis[id][x][y] = 0;
    while(head < tail){
        Node t = q[head++];
        for(int i = 0;i < 4;i++){
            int xx = t.x + dx[i],yy = t.y + dy[i];
            if(xx >= 0 && xx < n && yy >= 0 && yy < m && mp[xx][yy] == '.' && dis[id][xx][yy] == -1){
                dis[id][xx][yy] = dis[id][t.x][t.y] + 1;
                q[tail++] = {xx,yy};
            }
        }
    }
}

void add(int a,int b,long long w){
    to[++idx] = b,nxt[idx] = h[a],h[a] = idx,val[idx] = w;
    to[++idx] = a;nxt[idx] = h[b],h[b] = idx,val[idx] = 0;
}
bool bfs(int src,int des){
    int head = 0,tail = 0;
    for(int i = 0;i <= des;i++){step[i] = -1;cur[i] = h[i];}
    q2[tail++] = src;step[src] = 0;
    while(head < tail){
        int u = q2[head++];
        for(int i = h[u];i != -1;i = nxt[i]){
            int v = to[i];
            if(val[i] > 0 && step[v] == -1){
                step[v] = step[u] + 1;
                q2[tail++] = v;
            }
        }
    }
    return step[des] != -1;
}
long long dfs(int u,int des,long long flow){
    if(u == des)return flow;
    for(int i = cur[u];i != -1;i = nxt[i]){
        cur[u] = i;int v = to[i];
        if(val[i] > 0 && step[v] == step[u] + 1){
            long long f = dfs(v,des,min(flow,val[i]));
            if(f > 0){
                val[i] -= f;
                val[i ^ 1] += f;
                return f;
            }
        }
    }return 0;
}
bool check(int T){
    idx = -1;int src = 0,des = R + D * T + 2;
    //建图
    for(int i = 0;i <= des;i++)h[i] = -1;
    //原点到空地
    for(int i = 0;i < n;i++){
        for(int j = 0;j < m;j++){
            if(mp[i][j] == '.'){
                add(src,G[i][j],1);
            }
        }
    }
    //空地到门口
    for(int i = 0;i < n;i++){
        for(int j = 0;j < m;j++){
            if(mp[i][j] == '.'){
                for(int d = 1;d <= D;d++){
                    if(dis[d][i][j] != -1 && dis[d][i][j] <= T){
                        for(int dt = dis[d][i][j];dt <= T;dt++){
                            add(G[i][j],R + (d - 1) * T + dt + 1,1);
                        }
                    }
                }
            }
        }
    }
    //门口到汇点
    for(int d = 1;d <= D;d++){
        for(int t = 1;t <=T;t++){
            add(R + (d - 1) * T + t + 1,des,1);
            if(t != T){
                add(R + (d - 1) * T + t + 1,R + (d - 1) * T + t + 2,1e9);
            }
        }
    }
    //dinic
    long long maxflow = 0;
    while(bfs(src,des)){
        long long f = 0;
        while((f = dfs(src,des,1e9)) > 0){
            maxflow += f;
        }
    }
    return maxflow == R;
}

void solve(){
    cin >> n >> m;
    for(int i = 0;i < n;i++){
        cin >> mp[i];
    }
    R = D = 0;
    for(int i = 0;i < n;i++){
        for(int j = 0;j < m;j++){
            if(mp[i][j] == '.'){G[i][j] = ++R;}
            else if(mp[i][j] == 'D')bfs_dis(++D,i,j);
        }
    }
    int res = -1;int l = 1,r = 500;
    while(l <= r){
        int mid = (l + r) >> 1;
        if(check(mid)){
            res = mid;
            r = mid - 1;
        }else{
            l = mid + 1;
        }
    }
    if(res == -1)cout << "impossible\n";
    else cout << res << "\n";
}
int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int t = 1;
    while(t --){
        solve();
    }
    return 0;
}
```
