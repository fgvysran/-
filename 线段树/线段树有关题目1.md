[3721. 最长平衡子数组 II - 力扣（LeetCode）](https://leetcode.cn/problems/longest-balanced-subarray-ii/description/)

题意:

```
给你一个整数数组 nums。

如果子数组中 不同偶数 的数量等于 不同奇数 的数量，则称该 子数组 是 平衡的 。

返回 最长 平衡子数组的长度。
```

```
这个问题表面上看是「不同奇偶数数量」的比较，但如果我们从动态的角度来理解，可以发现：

我们只关心 奇数与偶数的数量差；(数量差相等的两个位置为一个平衡子数组的左右边界)

每遇到一个新数字时，根据它的奇偶性调整差值；

同一个数的重复出现，会让之前对区间的影响 被撤销（反转）。

```

```


用sum[i] 表示前 i 个数处理后的前缀和：(奇数+1，偶数-1，重复出现数为0)

每出现一个新奇数，sum[i] += 1，每出现一个新偶数，sum[i] -= 1

如果该数之前出现过，则要撤销前一次的贡献（即对之前那段区间加上相反数）（之前重复出现的数变为0）

那么：

当某两个位置 i、j 满足 sum[i] == sum[j] 时，它们之间的子数组 [i+1, j] 就是平衡子数组。

因为从 i 到 j 的平衡值没有变化，意味着奇偶数量的差回到原点。

因为会有重复数，sum会变化，每次变化大小为1，所以要用一种数据结构维护，并且支持区间加，查询快。

所以使用了支持「区间加法」与「查找第一个等于指定值」的 线段树 ，带懒标记，只需维护最大最小值

```

code:

```java
class Solution {
    public int longestBalanced(int[] nums) {
        int n = nums.length,res = 0,sum = 0;
        HashMap<Integer,Integer> map = new HashMap<>();
        ST s  = new ST(n);
        for(int i = 1;i <= n;i++){
            int add = (nums[i - 1] & 1) == 1?1:-1;
            if(map.containsKey(nums[i - 1])){
                s.add(1,0,n,map.get(nums[i - 1]),i - 1,-add);
            }else{
                s.add(1,0,n,i,n,add);sum += add;
            }
            map.put(nums[i - 1],i);
            int p = s.find_first(1,0,n,sum);
            if(p != -1){
                res = Math.max(res,i - p);
            }
        }return res;
    }
    class ST{
        class Node{
            int min,max,tag;
        }
        Node[]arr;
        public ST(int n){
            arr = new Node[n * 4 + 5];
            build(1,0,n);
        }
        public void build(int idx,int l,int r){
            arr[idx] = new Node();
            if(l == r)return;
            int m = (l + r) >> 1;
            build(idx << 1,l,m);
            build((idx << 1) | 1,m + 1,r);
        }
        public void DOWN(int idx){
            if(arr[idx].tag == 0)return;
            arr[idx << 1].min += arr[idx].tag;
            arr[idx << 1].max += arr[idx].tag;
            arr[idx << 1].tag += arr[idx].tag;

            arr[(idx << 1) | 1].min += arr[idx].tag;
            arr[(idx << 1) | 1].max += arr[idx].tag;
            arr[(idx << 1) | 1].tag += arr[idx].tag;

            arr[idx].tag = 0;
        }
        public void maintain(int idx){
            arr[idx].min = Math.min(arr[idx << 1].min,arr[(idx << 1) | 1].min);
            arr[idx].max = Math.max(arr[idx << 1].max,arr[(idx << 1) | 1].max);
        }
        public void add(int idx,int l,int r,int al,int ar,int add){
            if(ar < l || r < al)return;
            if(al <= l && r <= ar){
                arr[idx].max += add;
                arr[idx].min += add;
                arr[idx].tag += add;
                return;
            }
            DOWN(idx);
            int mid = (l + r) >> 1;
            if(al <= mid){
                add(idx << 1,l,mid,al,ar,add);
            }
            if(ar > mid){
                add((idx << 1) | 1,mid + 1,r,al,ar,add);
            }
            maintain(idx);
        }
        public int find_first(int idx,int l,int r,int sum){
            if(arr[idx].min > sum || arr[idx].max < sum)return -1;
            if(l == r) {//到底了
                return arr[idx].min == sum?l:-1;
            }
            DOWN(idx);
            int mid = (l + r) >> 1;
            int res = find_first(idx << 1,l,mid,sum);
            if(res == -1){
                res = find_first((idx << 1) | 1,mid + 1,r,sum);
            }return res;
        }
    }
}
```
