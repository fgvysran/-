[3721. 最长平衡子数组 II - 力扣（LeetCode）](https://leetcode.cn/problems/longest-balanced-subarray-ii/description/)

题意:

```
给你一个整数数组 nums。

如果子数组中 不同偶数 的数量等于 不同奇数 的数量，则称该 子数组 是 平衡的 。

返回 最长 平衡子数组的长度。
```

```
这个问题表面上看是「不同奇偶数数量」的比较，但如果我们从动态的角度来理解，可以发现：

我们只关心 奇数与偶数的数量差；(数量差相等的两个位置为一个平衡子数组的左右边界)

每遇到一个新数字时，根据它的奇偶性调整差值；

同一个数的重复出现，会让之前对区间的影响 被撤销（反转）。
```

```
用sum[i] 表示前 i 个数处理后的前缀和：(奇数+1，偶数-1，重复出现数为0)

每出现一个新奇数，sum[i] += 1，每出现一个新偶数，sum[i] -= 1

如果该数之前出现过，则要撤销前一次的贡献（即对之前那段区间加上相反数）（之前重复出现的数变为0）

那么：

当某两个位置 i、j 满足 sum[i] == sum[j] 时，它们之间的子数组 [i+1, j] 就是平衡子数组。

因为从 i 到 j 的平衡值没有变化，意味着奇偶数量的差回到原点。

因为会有重复数，sum会变化，每次变化大小为1，所以要用一种数据结构维护，并且支持区间加，查询快。

所以使用了支持「区间加法」与「查找第一个等于指定值」的 线段树 ，带懒标记，只需维护最大最小值
```

code:

```java
class Solution {
    public int longestBalanced(int[] nums) {
        int n = nums.length,res = 0,sum = 0;
        HashMap<Integer,Integer> map = new HashMap<>();
        ST s  = new ST(n);
        for(int i = 1;i <= n;i++){
            int add = (nums[i - 1] & 1) == 1?1:-1;
            if(map.containsKey(nums[i - 1])){
                s.add(1,0,n,map.get(nums[i - 1]),i - 1,-add);
            }else{
                s.add(1,0,n,i,n,add);sum += add;
            }
            map.put(nums[i - 1],i);
            int p = s.find_first(1,0,n,sum);
            if(p != -1){
                res = Math.max(res,i - p);
            }
        }return res;
    }
    class ST{
        class Node{
            int min,max,tag;
        }
        Node[]arr;
        public ST(int n){
            arr = new Node[n * 4 + 5];
            build(1,0,n);
        }
        public void build(int idx,int l,int r){
            arr[idx] = new Node();
            if(l == r)return;
            int m = (l + r) >> 1;
            build(idx << 1,l,m);
            build((idx << 1) | 1,m + 1,r);
        }
        public void DOWN(int idx){
            if(arr[idx].tag == 0)return;
            arr[idx << 1].min += arr[idx].tag;
            arr[idx << 1].max += arr[idx].tag;
            arr[idx << 1].tag += arr[idx].tag;

            arr[(idx << 1) | 1].min += arr[idx].tag;
            arr[(idx << 1) | 1].max += arr[idx].tag;
            arr[(idx << 1) | 1].tag += arr[idx].tag;

            arr[idx].tag = 0;
        }
        public void maintain(int idx){
            arr[idx].min = Math.min(arr[idx << 1].min,arr[(idx << 1) | 1].min);
            arr[idx].max = Math.max(arr[idx << 1].max,arr[(idx << 1) | 1].max);
        }
        public void add(int idx,int l,int r,int al,int ar,int add){
            if(ar < l || r < al)return;
            if(al <= l && r <= ar){
                arr[idx].max += add;
                arr[idx].min += add;
                arr[idx].tag += add;
                return;
            }
            DOWN(idx);
            int mid = (l + r) >> 1;
            if(al <= mid){
                add(idx << 1,l,mid,al,ar,add);
            }
            if(ar > mid){
                add((idx << 1) | 1,mid + 1,r,al,ar,add);
            }
            maintain(idx);
        }
        public int find_first(int idx,int l,int r,int sum){
            if(arr[idx].min > sum || arr[idx].max < sum)return -1;
            if(l == r) {//到底了
                return arr[idx].min == sum?l:-1;
            }
            DOWN(idx);
            int mid = (l + r) >> 1;
            int res = find_first(idx << 1,l,mid,sum);
            if(res == -1){
                res = find_first((idx << 1) | 1,mid + 1,r,sum);
            }return res;
        }
    }
}
```

## 第二题

[F-求函数_牛客2025秋季算法编程训练联赛2-提升组](https://ac.nowcoder.com/acm/contest/119774/F)



1.fl(x) = kl * x + bl  , fr(x) = kr * x + br: 

fr(fl(1)) = kr * (kl * x + bl) + br

             = kl * kr * x  + kr * bl + br

新的k为kl * kr,b 为kr * bl + br

两个函数的k l 可以合并为一个新的函数新的k 和l

涉及单点修改和区间查看k,b所以使用线段树维护,

x = 1最终区间查询答案为最终k + b

```java
import java.io.*;
import java.util.*;

public class Main {
    static BufferedReader br;
    static PrintWriter pw;
    static final int MOD = 1000000007;
    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        st = new StringTokenizer(br.readLine());
        int[]k = new int[n + 1];
        for(int i = 1;i <= n;i++){
            k[i] = Integer.parseInt(st.nextToken());
        }
        st = new StringTokenizer(br.readLine());
        int[]b = new int[n + 1];
        for(int i = 1;i <= n;i++){
            b[i] = Integer.parseInt(st.nextToken());
        }
        ST seg = new ST(k,b,n);
        for(int choice,i = 1;i <= m;i++){
            st = new StringTokenizer(br.readLine());
            choice = Integer.parseInt(st.nextToken());
            if(choice == 1){
                int x = Integer.parseInt(st.nextToken()),y = Integer.parseInt(st.nextToken()),z = Integer.parseInt(st.nextToken());
                seg.modefy(1,1,n,x,y,z);
            }else{
                int l = Integer.parseInt(st.nextToken()),r = Integer.parseInt(st.nextToken());
                int[] res = seg.query(1,1,n,l,r);
                pw.println((res[0] + res[1]) % MOD);
            }
        }
        //
        pw.flush();
        pw.close();br.close();
    }
    public static class ST{
        static class Node{
            int k,b;
        }
        Node[]arr;
        public ST(int[]k,int[]b,int n){
            arr = new Node[n * 4 + 7];
            build(1,1,n,k,b);
        }
        public int[] query(int id,int l,int r,int x,int y){
            if(l == r){
                return new int[]{arr[id].k,arr[id].b};
            }
            if(x <= l && r <= y){
                return new int[]{arr[id].k,arr[id].b};
            }
            int mid = (l + r) >> 1;
            int[]left = null,right = null;
            if(x <= mid){
                left = query(id << 1,l,mid,x,y);
            }
            if(y > mid){
                right = query(id << 1 | 1,mid + 1,r,x,y);
            }
            if(left == null){
                return right;
            }else if(right == null){
                return left;
            }else{
                long k = (long)left[0] * right[0] % MOD;
                long b = ((long)left[1] * right[0] % MOD + right[1] % MOD) % MOD;
                return new int[]{(int)k,(int)b};
            }
        }
        public void modefy(int id,int l,int r,int x,int k,int b){
            if(l == r){
                arr[id].k = k;arr[id].b = b;
                return;
            }
            int mid = (l + r) >> 1;
            if(x <= mid){
                modefy(id << 1,l,mid,x,k,b);
            }else{
                modefy(id << 1 | 1,mid + 1,r,x,k,b);
            }
            maintain(id);
        }
        public void build(int id,int l,int r,int[]k,int[]b){
            arr[id] = new Node();
            if(l == r){
                arr[id].k = k[l];arr[id].b = b[l];return;
            }
            int mid = (l + r) >> 1;
            build(id << 1,l,mid,k,b);
            build(id << 1 | 1,mid + 1,r,k,b);
            maintain(id);
        }
        public void maintain(int id){
            int i = id << 1,j = i | 1;
            arr[id].k =(int) ((long)arr[i].k * arr[j].k % MOD);
            arr[id].b = (int)(((long)arr[j].k * arr[i].b % MOD + arr[j].b % MOD) % MOD);
        }
    }
}

```
