[1625. 执行操作后字典序最小的字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/description/?envType=daily-question&envId=2025-10-19)

```java
(1)考虑累加
si为i为上的字符，a为累加数，k为累加了a多少次，r 为si可以累加到的值

(si + ak) % 10 = r

si + ak - 10 * t = r

ak- 10 * t = r - si

g = gcd(a,10) 能被 r - si 整除有解

r 同余 si (mod g)

r最小值为si % g

add = si % g - si + 10 (保证>= 0)

(2)同理考虑轮转:

(pi + b * k) % n = r2

pi + b * k - n * t = r2

b * k - n * t = r2 - pi

g2 = gcd(b,n)能被 r2 - pi 整除有解

r2 同余 pi (mod g2)

r2 值为g2倍数 + pi

枚举pi = 0就可以考虑到所有轮转情况

g2为奇数的话，偶数位也可以进行累加



枚举所有轮转，轮转中累加得到左边数最小，统计答案去最小值
```

```java
class Solution {
    public String findLexSmallestString(String s, int a, int b) {
        char[]sa = s.toCharArray(),sb = s.toCharArray();
        int n = sa.length;
        int g = gcd(a,10);
        int g2 = gcd(b,n);
        String res = s;
        for(int i = 0;i < n;i += g2){
            System.arraycopy(sb,i,sa,0,n - i);
            System.arraycopy(sb,0,sa,n - i,i);
            change(sa,1,g);
            if((g2 & 1) == 1){
                change(sa,0,g);
            }
            String x = new String(sa);
            if(x.compareTo(res) < 0){
                res = x;
            }
        }return res;
    }
    public void change(char[]a,int st,int g){
        int t = a[st] - '0';
        int add = t % g - t + 10;//不能往回减，保证不为负数
        for(int i = st,n = a.length;i < n;i += 2){
            a[i] =(char)( (a[i] - '0' + add ) % 10 + '0');
        }
    }
    public int gcd(int a,int b){
        return b == 0?a:gcd(b,a % b);
    }

}
```
