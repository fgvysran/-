[3003. 执行操作后的最大分割数量 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-the-number-of-partitions-after-operations/description/?envType=daily-question&envId=2025-10-17)

```java
//每个状态中要么改变元素，要么不改
//从左到右枚举每个字符，维护当前子串包含的字符种类情况
//（带状态的区间划分 + 记忆化搜索做法）该题核心难点在于：
//1.什么时候需要“断开一段”；2.什么时候选择“修改当前字符”；3.怎么防止状态重复计算。
class Solution {
    HashMap<Long,Integer> map;
    public int maxPartitionsAfterOperations(String s, int k) {
        map = new HashMap<>();
        return dfs(s,0,0,k,0);//处理到第几位，不同元素数量,k,是否改变元素
    }
    public int dfs(String s,int i,int mask,int k,int change){
        if(i == s.length()){
            return 1;
        }
        long now = ((long)i << 32) | (mask << 1) | change;
        if(map.containsKey(now))return map.get(now);
        int res = 0;
        int c = 1 << (s.charAt(i) - 'a');
        int newMask = mask | c;
        //不改:
        if(Integer.bitCount(newMask) > k){
            res = 1 + dfs(s,i + 1,c,k,change);
        }else{
            res = dfs(s,i + 1,newMask,k,change);
        }
        //改元素:
        if(change == 0){    
            for(int x = 0;x < 26;x++){
                c = 1 << x;
                newMask = mask | c;
                if(Integer.bitCount(newMask) > k){
                    res = Math.max(1 + dfs(s,i + 1,c,k,1),res);
                }else{
                    res = Math.max(res,dfs(s,i  + 1,newMask,k,1));
                }
            }
        }
        map.put(now,res);
        return res;
    }
}
```
