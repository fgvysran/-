[3720. 大于 target 的最小字典序排列 - 力扣（LeetCode）](https://leetcode.cn/problems/lexicographically-smallest-permutation-greater-than-target/description/)

思路

前面的字符尽可能和 target 一样；

在某个位置上选一个比 target 当前位稍大的字符；(倒序)

剩下的部分尽可能按最小字典序排列。



从右往左枚举可能的“变更点”位置 i：

假设我们想在第 i 位换一个更大的字符；

那么在右边部分 i+1..n-1，我们可以自由重排，使整体最小；

我们要确保：在换第 i 位前，左边 0..i-1 的部分仍能匹配（即可用字符足够）。

所以，我们逆序遍历 target，尝试找到最右边能变大的位置，保证整体最小。

```java
class Solution {//贪心 + 枚举 + 计数约束
    public String lexGreaterPermutation(String s, String target) {
        int n = s.length();
        int[] cnt = new int[26];
        for(int i = 0;i < n;i++){
            cnt[s.charAt(i) - 'a'] += 1;
            cnt[target.charAt(i) - 'a'] -= 1;
        }//// cnt[x] 记录 s 与 target 的字符差异
        StringBuilder sb = new StringBuilder(target);
        for(int i = n - 1;i >= 0;i--){
            int now = target.charAt(i) - 'a';
            cnt[now]++;//// 把第 i 位“还回去”，表示可以自由替换
            boolean f = false;
            for(int j = 0;j < 26;j++){
                if(cnt[j] < 0){//// s 中字符不足
                    f = true;
                }
            }
            if(f)continue;///// 无法匹配当前前缀，跳过
            for(int j = now + 1;j < 26;j++){// 尝试将当前位置换成比 target[i] 大的字符
                if(cnt[j] > 0){
                    cnt[j] --;
                    sb.setCharAt(i,(char)(j + 'a'));
                    sb.setLength(i + 1);
                    for(int k = 0;k < 26;k++){// 把剩余字符按最小字典序追加
                        while(cnt[k] > 0){
                            cnt[k] -= 1;
                            sb.append((char)(k + 'a'));
                        }
                    }
                    return sb.toString();
                }
            }
        }return "";
    }
}


```
