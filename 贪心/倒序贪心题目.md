## 题目1:

[3720. 大于 target 的最小字典序排列 - 力扣（LeetCode）](https://leetcode.cn/problems/lexicographically-smallest-permutation-greater-than-target/description/)

思路

前面的字符尽可能和 target 一样；

在某个位置上选一个比 target 当前位稍大的字符；(倒序)

剩下的部分尽可能按最小字典序排列。

从右往左枚举可能的“变更点”位置 i：

假设我们想在第 i 位换一个更大的字符；

那么在右边部分 i+1..n-1，我们可以自由重排，使整体最小；

我们要确保：在换第 i 位前，左边 0..i-1 的部分仍能匹配（即可用字符足够）。

所以，我们逆序遍历 target，尝试找到最右边能变大的位置，保证整体最小。

```java
class Solution {//贪心 + 枚举 + 计数约束
    public String lexGreaterPermutation(String s, String target) {
        int n = s.length();
        int[] cnt = new int[26];
        for(int i = 0;i < n;i++){
            cnt[s.charAt(i) - 'a'] += 1;
            cnt[target.charAt(i) - 'a'] -= 1;
        }//// cnt[x] 记录 s 与 target 的字符差异
        StringBuilder sb = new StringBuilder(target);
        for(int i = n - 1;i >= 0;i--){
            int now = target.charAt(i) - 'a';
            cnt[now]++;//// 把第 i 位“还回去”，表示可以自由替换
            boolean f = false;
            for(int j = 0;j < 26;j++){
                if(cnt[j] < 0){//// s 中字符不足
                    f = true;
                }
            }
            if(f)continue;///// 无法匹配当前前缀，跳过
            for(int j = now + 1;j < 26;j++){// 尝试将当前位置换成比 target[i] 大的字符
                if(cnt[j] > 0){
                    cnt[j] --;
                    sb.setCharAt(i,(char)(j + 'a'));
                    sb.setLength(i + 1);
                    for(int k = 0;k < 26;k++){// 把剩余字符按最小字典序追加
                        while(cnt[k] > 0){
                            cnt[k] -= 1;
                            sb.append((char)(k + 'a'));
                        }
                    }
                    return sb.toString();
                }
            }
        }return "";
    }
}
```

## 题目2：

[3397. 执行操作后不同元素的最大数量 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-distinct-elements-after-operations/description/?envType=daily-question&envId=2025-10-18)

该题贪心核心：能选最小的不同数就选最小的，这样后面的数才有更多空间选择

### 💡思路解析💡💡💡

1. **排序**数组，使相邻元素尽量靠近，方便贪心处理。

2. 维护一个变量 `pre` 表示上一个已经选定的不重复数字。

3. 对于当前数 `nums[i]`：
   
   - 它能取的范围是 `[nums[i] - k, nums[i] + k]`；
   
   - 我们希望它尽可能小、但又要大于 `pre`（保证不重复）。
   
   - 因此选取的值为：  
     `x = min(max(nums[i] - k, pre + 1), nums[i] + k)`

4. 若 `x > pre`，说明能选出一个新的不同数，更新 `pre = x`，计数 `res++`。

```java
class Solution {
    public int maxDistinctElements(int[] nums, int k) {
        int n = nums.length;
        int res = 0;
        Arrays.sort(nums);
        int pre = Integer.MIN_VALUE;//维护左边最大数
        for(int i = 0;i < n;i++){
            //当前位置数最小值
            int x = Math.min(Math.max(nums[i] - k,pre + 1),nums[i] + k);
            //nums[i] + k 上界，max(nums[i] - k,pre + 1)下界
            if(x > pre){
                pre = x;
                res++;
            }
        }
        return res;
    }
}
```

## 第三题:

完全背包加贪心

[1449. 数位成本和为目标值的最大数字 - 力扣（LeetCode）](https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/description/)

完全背包求出最终能得到的数的最大长度

然后贪心构造数从大到小，根据动态规划链逆向判断该数可不可以填

```java
class Solution {
    public String largestNumber(int[] cost, int target) {
        int[]f = new int[target + 1];
        Arrays.fill(f,Integer.MIN_VALUE);
        f[0] = 0;
        for(int i = 1;i <= target;i++){
            for(int j = 0;j < 9;j++){
                if(i - cost[j] >= 0){
                    f[i] = Math.max(f[i] ,1 + f[i - cost[j]]);
                }
            }
        }
        if(f[target] < 0)return "0";
        StringBuilder ans = new StringBuilder();
        for(int i = 8;i >= 0;i--){
            while(target - cost[i] >= 0 && f[target- cost[i]] + 1 == f[target]){
                ans.append(i + 1);
                target -= cost[i];
            }
            if(target == 0)break;
        }
        return ans.toString();
    }
}
```
