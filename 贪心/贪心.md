## 题目1:

[3720. 大于 target 的最小字典序排列 - 力扣（LeetCode）](https://leetcode.cn/problems/lexicographically-smallest-permutation-greater-than-target/description/)

思路

前面的字符尽可能和 target 一样；

在某个位置上选一个比 target 当前位稍大的字符；(倒序)

剩下的部分尽可能按最小字典序排列。

从右往左枚举可能的“变更点”位置 i：

假设我们想在第 i 位换一个更大的字符；

那么在右边部分 i+1..n-1，我们可以自由重排，使整体最小；

我们要确保：在换第 i 位前，左边 0..i-1 的部分仍能匹配（即可用字符足够）。

所以，我们逆序遍历 target，尝试找到最右边能变大的位置，保证整体最小。

```java
class Solution {//贪心 + 枚举 + 计数约束
    public String lexGreaterPermutation(String s, String target) {
        int n = s.length();
        int[] cnt = new int[26];
        for(int i = 0;i < n;i++){
            cnt[s.charAt(i) - 'a'] += 1;
            cnt[target.charAt(i) - 'a'] -= 1;
        }//// cnt[x] 记录 s 与 target 的字符差异
        StringBuilder sb = new StringBuilder(target);
        for(int i = n - 1;i >= 0;i--){
            int now = target.charAt(i) - 'a';
            cnt[now]++;//// 把第 i 位“还回去”，表示可以自由替换
            boolean f = false;
            for(int j = 0;j < 26;j++){
                if(cnt[j] < 0){//// s 中字符不足
                    f = true;
                }
            }
            if(f)continue;///// 无法匹配当前前缀，跳过
            for(int j = now + 1;j < 26;j++){// 尝试将当前位置换成比 target[i] 大的字符
                if(cnt[j] > 0){
                    cnt[j] --;
                    sb.setCharAt(i,(char)(j + 'a'));
                    sb.setLength(i + 1);
                    for(int k = 0;k < 26;k++){// 把剩余字符按最小字典序追加
                        while(cnt[k] > 0){
                            cnt[k] -= 1;
                            sb.append((char)(k + 'a'));
                        }
                    }
                    return sb.toString();
                }
            }
        }return "";
    }
}
```

## 题目2：

[3397. 执行操作后不同元素的最大数量 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-of-distinct-elements-after-operations/description/?envType=daily-question&envId=2025-10-18)

该题贪心核心：能选最小的不同数就选最小的，这样后面的数才有更多空间选择

### 💡思路解析💡💡💡

1. **排序**数组，使相邻元素尽量靠近，方便贪心处理。

2. 维护一个变量 `pre` 表示上一个已经选定的不重复数字。

3. 对于当前数 `nums[i]`：
   
   - 它能取的范围是 `[nums[i] - k, nums[i] + k]`；
   
   - 我们希望它尽可能小、但又要大于 `pre`（保证不重复）。
   
   - 因此选取的值为：  
     `x = min(max(nums[i] - k, pre + 1), nums[i] + k)`

4. 若 `x > pre`，说明能选出一个新的不同数，更新 `pre = x`，计数 `res++`。

```java
class Solution {
    public int maxDistinctElements(int[] nums, int k) {
        int n = nums.length;
        int res = 0;
        Arrays.sort(nums);
        int pre = Integer.MIN_VALUE;//维护左边最大数
        for(int i = 0;i < n;i++){
            //当前位置数最小值
            int x = Math.min(Math.max(nums[i] - k,pre + 1),nums[i] + k);
            //nums[i] + k 上界，max(nums[i] - k,pre + 1)下界
            if(x > pre){
                pre = x;
                res++;
            }
        }
        return res;
    }
}
```

## 第三题:

完全背包加贪心

[1449. 数位成本和为目标值的最大数字 - 力扣（LeetCode）](https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/description/)

完全背包求出最终能得到的数的最大长度

然后贪心构造数从大到小，根据动态规划链逆向判断该数可不可以填

```java
class Solution {
    public String largestNumber(int[] cost, int target) {
        int[]f = new int[target + 1];
        Arrays.fill(f,Integer.MIN_VALUE);
        f[0] = 0;
        for(int i = 1;i <= target;i++){
            for(int j = 0;j < 9;j++){
                if(i - cost[j] >= 0){
                    f[i] = Math.max(f[i] ,1 + f[i - cost[j]]);
                }
            }
        }
        if(f[target] < 0)return "0";
        StringBuilder ans = new StringBuilder();
        for(int i = 8;i >= 0;i--){
            while(target - cost[i] >= 0 && f[target- cost[i]] + 1 == f[target]){
                ans.append(i + 1);
                target -= cost[i];
            }
            if(target == 0)break;
        }
        return ans.toString();
    }
}
```

## 第四题

[135. 分发糖果 - 力扣（LeetCode）](https://leetcode.cn/problems/candy/description/)

两次遍历即可：把所有孩子的糖果数初始化为；
先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的
糖果数加；再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数
不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加。通过这两次遍历，
分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一
侧的大小关系。

```java
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        if(n < 2)return n;
        int[]arr = new int[n];
        Arrays.fill(arr,1);
        for(int i = 1;i < n;i++){
            if(ratings[i] > ratings[i - 1])arr[i] = arr[i - 1] + 1;
        }
        int res = arr[n - 1];
        for(int i = n - 2;i >= 0;i--){
            if(ratings[i] > ratings[i + 1]){
                arr[i] = Math.max(arr[i + 1] + 1,arr[i]);
            }
            res += arr[i];
        }return res;
    }
}
```

## 第五题

[435. 无重叠区间 - 力扣（LeetCode）](https://leetcode.cn/problems/non-overlapping-intervals/description/)

在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间
就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区
间。

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals,(a,b)->a[1] - b[1]);
        int n = intervals.length;
        int pre = intervals[0][1],ans = 0;
        for(int i = 1;i < n;i++){
            if(intervals[i][0] < pre){
                ans++;
            }else{
                pre = intervals[i][1];
            }
        }
        return ans;
    }
}
```

## 第六题

[452. 用最少数量的箭引爆气球 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

**让每一支箭都尽可能地射爆更多的气球**，维护最大有序右区间

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points,(a,b)->{
            if(a[1] != b[1]){
                return a[1] <= b[1]?-1:1;
            }
            return a[0] <= b[0]?-1:1;
        });
        int r = points[0][1],ans = 1;
        for(int i = 1,n = points.length;i < n;i++){
            if(points[i][0] <= r){
                continue;
            }else{
                ans++;r = points[i][1];
            }
        }
        return ans;
    }
}
```

## 第七题

[763. 划分字母区间 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-labels/description/)

同一字母最多出现在一个片段中，自然而然想到辅助数组记录最后一个相等的字母的下标位置。

然后如果这个范围内，出现了最后一个数更大的下标，则更新区间r。

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        int[]lastInd = new int[26];
        int n = s.length();
        List<Integer> res = new ArrayList<>();
        for(int i = 0;i < n;i++){
            int t = s.charAt(i) - 'a';
            lastInd[t] = i;
        }
        for(int l = 0;l < n;l++){
            int t = s.charAt(l) - 'a';
            int r = lastInd[t];
            int left = l + 1;
            while(left <= r){
                r = Math.max(r,lastInd[s.charAt(left) - 'a']);
                left++;
            }
            res.add(r - l + 1); l = r;
        }
        return res;
    }
}
```

## 第八题

[122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

- **最优性**  
  所有从价格上涨中能获得的利润全部获取，没有遗漏

- **无悔性**  
  不会在下降期间持有股票，无不必要亏损

对于任意一段上升区间，将其全部差价加起来等价于在最低点买、最高点卖。

对于任意一个下降区间参与交易只会亏钱，所以不应该买入或持有。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int res = 0,in = -1;
        for(int i = 0;i < n;i++){
            if(in == -1 && i + 1 < n && prices[i] < prices[i + 1]){
                in = prices[i];continue;
            }
            if(in != -1 && i + 1 < n && prices[i]  > prices[i + 1]){
                res +=  prices[i] - in;in  = -1;
            }
        }
        if(in != -1)res += prices[n - 1] - in;
        return res;
    }
}
```

## 第九题

[406. 根据身高重建队列 - 力扣（LeetCode）](https://leetcode.cn/problems/queue-reconstruction-by-height/description/)

按身高从大到小排序，身高相同，按k从小到大排序。

📌 **高个子排好位置 → 不会影响别人**  
📌 **矮个子后排 → 更容易找到符合规则的位置**

- 高个子先排 → 不会影响后面的人

- 位置就是 k → 保证前面刚好有 k 个 >= 他的人

- 每插一个都正确 → 最终整体就对了

📌这是**局部最优（每次插对位置）**  
📌最终得到**全局最优（整个队列满足规则）**

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people,(a,b)->{
            if(a[0] != b[0]){
                return a[0] >= b[0]?-1:1;
            }
            return a[1] <= b[1]?-1:1;
        });
        int n = people.length;
        for(int i = 0;i < n;i++){
            int h = people[i][0],k = people[i][1];
            if(k == i)continue;
            int j = i;
            while(j > k){
                swap(people,j,j - 1);j--;
            }
        }
        return people;
    }
    public void swap(int[][]arr,int i,int j){
        int h = arr[i][0],k = arr[i][1];
        arr[i][0] = arr[j][0];arr[i][1] = arr[j][1];
        arr[j][0] = h;arr[j][1] = k;
    }
}
```

## 第10题

[665. 非递减数列 - 力扣（LeetCode）](https://leetcode.cn/problems/non-decreasing-array/description/)

如果可以把大的变小就变小，否则把小的变大。

```java
class Solution {
    public boolean checkPossibility(int[] nums) {
        int n = nums.length;
        boolean f = false;
        for(int i = 0;i < n - 1;i++){
            if(nums[i] <= nums[i + 1])continue;
            if(f)return false;
            f = true;
            //
            if(i == 0 || nums[i - 1] <= nums[i + 1])nums[i] = nums[i + 1];
            else nums[i + 1] = nums[i];
        }
        return true;

    }
}
```
