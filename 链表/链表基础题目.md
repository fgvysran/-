## 题目1

[83. 删除排序链表中的重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)

简单删除节点练习

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null)return head;
        ListNode preNode = head,res = head;
        head = head.next;
        while(head != null){
            ListNode next = head.next;
            if(head.val == preNode.val){
                head.next = null;
                preNode.next = next;
            }else{
                preNode = head;
            }
            head = next;
        }
        return res;

    }
}
```

## 题目2

[328. 奇偶链表 - 力扣（LeetCode）](https://leetcode.cn/problems/odd-even-linked-list/description/)

简单链表连接

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if(head == null || head.next == null || head.next.next == null)return head;
        ListNode a = new ListNode(),b = new ListNode();
        ListNode pa = a,pb = b;
        int cnt = 1;
        while(head != null){
            ListNode next = head.next;
            head.next = null;
            if((cnt & 1) != 0){
                pa.next = head;
                pa = pa.next;
            }else{
                pb.next = head;
                pb = pb.next;
            }
            head = next;
            cnt++;
        }
        pa.next = b.next;
        return a.next;
    }
}
```

## 题目3

[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

简单删除节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int len = length(head);
        n = len - n + 1;//删除第几个
        ListNode h = new ListNode();h.next = head;
        n--;
        ListNode pre = h;
        for(int i = 0;i < n;i++){
            head = head.next;pre = pre.next;
        }
        pre.next = head.next;
        return h.next;
    }
    public int length(ListNode head){
        if(head == null)return 0;
        int res = 0;
        while(head != null){
            res ++;
            head = head.next;
        }
        return res;
    }
}
```

## 题目4

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)

简单反转链表

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null)return head;
        ListNode pre = null;
        while(true){
            ListNode next = head.next;
            head.next = pre;
            pre = head;
            if(next == null)break;
            head = next;
        }
        return head;
    }
}
```

## 题目5

简单置换节点

[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null)return head;
        ListNode pre = null, p = head,res = head.next;
        while(p != null){
            if(p.next == null){
                pre.next = p;break;
            }
            ListNode next = p.next.next,p2 = p.next;
            p2.next = p;p.next = null;
            if(pre != null)pre.next = p2;
            pre = p;
            p = next;
        }
        return res;
    }
}
```

## 题目5

[LCR 023. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/3u1WK4/description/)

链表交点，一共走a + b的长度

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == null || headB == null)return null;
        ListNode p1 = headA,p2= headB;
        while(p1 != p2){
            p1 = p1 == null?headB:p1.next;
            p2 = p2 == null?headA:p2.next;
        }return p1;
    }
}
```

## 题目6

[LCR 022. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/c32eOV/description/)

判断有没有环

a + x  - a = x(low 圈内走了)

2 * (a + x) - x - a = a + x(fast圈内走了)

low 变为head,和fast同时走直到相遇

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null || head.next == null)return null;
        ListNode low = head,fast = head;
        while(true){
            if(fast == null || fast.next == null)return null;
            low = low.next;fast = fast.next.next;
            if(low == fast)break;
        }
        low = head;
        while(low != fast){
            low = low.next;fast = fast.next;
        }
        return low;
    }
}
```

。
