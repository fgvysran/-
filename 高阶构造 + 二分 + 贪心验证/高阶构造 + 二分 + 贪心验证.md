## 题目一

[Problem - E - Codeforces](https://codeforces.com/contest/2156/problem/E)



二分枚举最终美感值。

利用check（mid）函数判断 双方都采取最优策略的情况下，最终阵列的美感值是否能 >= mid。

count[i] 表示i下标中满足(下标j < i && arr[i] - arr[j] >= mid 和 下标j > i && arr[j] - arr[i] >= mid)的数量.

如果最大的count[i]小于2则说明该mid值是取不到的，Hao每次都可以抢先一步删除其中一个值，让Alex无法取到.

如果count[i] 有大于2的，那么Hao必须抢先删除i,然后，再求一次count(不包含下标i),如果此时count里还有值 >= 2的，那么>=mid就可以取到

最后一种情况就是count里值最大为2,准备一个p数组,遍历count,如果count==2，那么Hao必然删除其中一个，枚举j（1-n）将满足(下标j < i && arr[i] - arr[j] >= mid 和 下标j > i && arr[j] - arr[i] >= mid)的下标j放入p数组,i也要放入.然后遍历p数组,每次重新求一次count(不包含下标p[i]),如果存在最大count值 < 2,那么该mid就是取不到，Hao会成功阻止使其尽可能小



count[]数组该怎么求,O(n*n)会超时：（count最大值为3即可得出答案，再多无意义）

创建列表max和min

先从左到右扫描一次原数组，min记录i位置之前最小的三个数，遍历min数组，如果满足arr[i] - arr[j] >= mid，count[i]++；然后把原数组i位上的数加入min，然后排序min，然后如果min的大小大于3,就删除最大的一个数.

然后从右到左扫描原数组,max记录i位置之后最大的3个数，遍历max数组，如果满足arr[j] - arr[i] >= mid，count[i]++；然后把原数组i位上的的数加入max，然后排序max，然后如果max的大小大于3,就删除最小的一个数.

因为max,min数组大小很小，排序遍历时间复杂度位常数级别

所以总体变为o(n)

``` java
import java.io.*;
import java.util.*;

public class Main {
    static BufferedReader br;
    static PrintWriter pw;
    static final int MOD = 1000000007;
    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int t = Integer.parseInt(br.readLine());
        while(t-- > 0){
            solve();
        }
        pw.flush();
        pw.close();br.close();
    }
    public static void solve() throws IOException {
        int n = Integer.parseInt(br.readLine());
        int[]a = new int[n];
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i = 0;i < n;i++){
            a[i] = Integer.parseInt(st.nextToken());
        }
        int l = -1_000_000_007,r = 1_000_000_007;
        while(l < r){
            int mid = (r - l) / 2 + l;
            if(check(mid,a,n)){
                l = mid + 1;
            }else{
                r = mid;
            }
        }
        pw.println(l - 1);
    }
    public static boolean check(int g,int[]arr,int n){
        int[]count = getCount(g,arr,n,-1);
        int maxC = 0,ind = -1;
        for(int i = 0;i < n;i++){
            if(count[i] > maxC){maxC = count[i];ind = i;}
        }
        if(maxC < 2)return false;List<Integer>p = new ArrayList<>();
        if(maxC > 2){
            p.add(ind);
        }else{
            for(int i = 0;i < n;i++){
                if(count[i] == 2){
                    for(int j = 0;j < n;j++){
                        if(i == j)p.add(i);
                        else if(i < j && arr[j] - arr[i] >= g)p.add(j);
                        else if(i > j && arr[i] - arr[j] >= g)p.add(j);
                    }break;
                }
            }
        }
        for(int index:p){
            count = getCount(g,arr,n,index);maxC = 0;
            for(int i = 0;i < n;i++){
                if(count[i] > maxC){maxC = count[i];}
            }
            if(maxC < 2)return false;
        }
        return true;
    }
    public static int[]getCount(int g,int[]arr,int n,int del){
        List<Integer> min = new ArrayList<>(),max = new ArrayList<>();
        int[]count = new int[n];
        for(int i = 0;i < n;i++){
            if(i == del) {
                count[i] = 0;
                continue;
            }
            for(int x:min){
                if(arr[i] - x >= g)count[i]++;
            }
            min.add(arr[i]);
            min.sort((a,b)->a - b);
            if(min.size() > 3)min.remove(min.size()-1);
        }
        for(int i = n - 1;i >= 0;i--){
            if(i == del) {
                continue;
            }
            for(int x:max){
                if(x - arr[i] >= g)count[i]++;
            }
            max.add(arr[i]);
            max.sort((a,b)->b - a);
            if(max.size() > 3)max.remove(max.size()-1);
        }
        return count;
    }
}

```
